# 오답노트

### 72번 문제

1) 단일 행 서브쿼리의 비교 연산자로는 `=, <, <=, >, >=, <>`가 되어야 한다. IN, ALL 등의 비교 연산지는 다중 행 서브쿼리의 비교연산자이다.

2) 단일 행 서브쿼리의 비교연산자는 다중 행 서브쿼리의 비교 연산자로 사용할 수 없지만, 반대의 경우는 가능하다.

3) 비 연관 서브쿼리가 주로 메인쿼리에 값을 제공하기 위한 목적으로 사용된다.

4) 메인쿼리의 결과가 서브쿼리로 제공될 수도 있고, 서브쿼리의 결과가 메인쿼리로 제공될 수도 있으므로 실행 순서는 상황에 따라 달라진다.

### 73번 문제

- 2014년에 입사한 사원들의 사원, 부서 정보와 부양가족수를 추출하는 SQL이다.

- SELECT 절에 사용된 서브쿼리는 단일 행 연관 서브쿼리로 JOIN으로도 변경이 가능하며, FROM 절에 사용된 서브쿼리는 Inline View 또는 Dynamic View이고, WHERE 절에 사용된 서브쿼리는 다중행 연관 서브쿼리이다.

3) 번 보기의 경우 이미 FROM절에 Inline View로 사원 테이블의 입사년도 조건을 명시하였으므로 WHERE 절의 EXISTS 조건은 부서와 사원 테이블 간의 JOIN조건에 의해 결과에 어떠한 영향도 미치지 못하므로 삭제되어도 무방하다.

### 74번 문제

1) Inline View D에서 평가결과 엔터티의 틀정상품 및 평가항목에 대한 최종 평가회차가 아닌 전체 데이터 중 평가회차가 가장 큰 값을 가지고 JOIN을 수행하므로 원하는 결과가 아니다.

2) 연관 서브쿼리를 활용하여 특정 상품, 평가항목별로 최종 평가회차와 JOIN을 수행하여 원하는 결과를 출력한다.

3) 특정 평가회차에 대한 결과가 아닌, 평가결과 엔터티의 평가회차, 평가등급, 평가일자 속성에 대해서 개별 MAX 값을 구하므로 원하는 결과가 아니다.

4) 특정 평가회차에 대한 결과가 아닌 상품ID, 평가항목ID 별로 개별 MAX 값을 구하므로 원하는 결과가 아니다.

### 77번 문제

- COL1 구문은 부서ID별로 연봉의 내림차순으로 유일한 순위를 부여한다.

- COL2 구문은 부서ID별로 첫 행부터 현재 행까지의 범위에서 SUM값을 구한다.

- COL3 구문은 전체 데이터에서 현재 행부터 현재 행까지의 범위에서 가장 큰 연봉을 구한다.

- ROWS CURRENT ROW에서 BETWEEN이 없다면 뒤어 AND CURRENT ROW가 생략된 것과 동일하다. 즉 COL3 구문은 ROWS BETWEEN CURRENT ROW AND CURRENT ROW와 동일하다. -> 현재 행의 MAX 연봉이니까 그냥 연봉값이 추출됨

### 78번 문제

- ROLLUP 함수 활용

- ROLLUP 집계 그룹 함수는 나열된 칼럼에 대해 계층 구조로 집계를 출력하는 함수로 ROLLUP(A, B)를 수행하면 (A, B)별 집계, A별 집계와 전체 집계를 출력할 수 있다.

1) CASE절의 GROUPING 함수의 사용이 잘못(0이 아닌 1이 되어야 함)되었음

3) CUBE를 사용하면 결합 가능한 모든 값에 대하여 다차원 집계를 생성한다.

4) GROUPING SETS를 사용하면 계층 구조 없이 지역에 대한 합계와 원별 합계를 각각 생성한다

### 79번 문제

- 서브쿼리는 단일 행 또는 복수 행 비교 연산자와 함께 사용 가능하다. 단일 행 비교 연산자는 서브쿼리의 굘과가 반드시 1건 이하여야 하고, 복수 행 비교 연산자는 서브쿼리의 결과 건수와 상관없다.

### 80번 문제

- DNAME별 집계 와 전체 집계만 확인 되었으니 ROLLUP함수가 사용되어야 한다.

- JOB별 집계도 있었다면 CUBE함수가 사용되어야 한다.

- 전체 집계가 없이 DNAME별 집계와 JOB별 집계가 있었다면 GROUPING SET함수가 사용되어야 한다.

### 83번 문제

- GROUPING SETS 괄호가 1겹이 아니라 2겹 -> 상품ID와 월을 1세트로 취급해야한다. 만약 GROUPING SETS(상품ID, 월) 이였다면 답은 1번이 된다.

- 각 보기별 SQL

1) GROUPING SETS에 괄호를 사용하지 않아 월별과 상품ID 별로 각각 집계되었다.

```SQL
SELECT 상품ID, 월, SUM(매출액) AS 매출액
FROM 월별매출
WHERE 월 BETWEEN '2014.10' AND '2014.12'
GROUP BY GROUPING SETS(월, 상품ID);
```

3) GROUPING SETS에 월별, 상품ID별과 전체가 각각 집계되었다.

```SQL
SELECT 상품ID, 월, SUM(매출액) AS 매출액
FROM 월별매출
WHERE 월 BETWEEN '2014.10' AND '2014.12'
GROUP BY GROUPING SETS(월, 상품ID, ());
```

4) GROUPING SETS에 (월, 삼품ID)별, 월별로 집계되었다.

```SQL
SELECT 상품ID, 월, SUM(매출액) AS 매출액
FROM 월별매출
WHERE 월 BETWEEN '2014.10' AND '2014.12'
GROUP BY GROUPING SETS((월, 상품ID,), 월);
```

### 87번 문제

- ROW_NUMBER 함수는 ORDER BY 절에 의해 정렬된 데이터에 동일 값이 존재하더라도 유일한 순위를 부여하는 함수로서 데이터 그룹 내에 유일한 순위를 추출할 때 사용할 수 있는 함수이다.

- 문제의 SQL은 추천경로별(PARTITION BY 추천경로)로 추천점수가 가장 높은(ORDER BY 추천점수 DESC) 데이터를 한 건씩만 출력

1) 전체 데이터를 그대로 출력

2) 전체에서 추천점수가 가장 높은 데이터 한 건만을 출력

4) 추천경로별로 추천점수가 가장 낮은 데이터를 각 한 건씩 출력

### 88번 문제

- GROUP BY 절의 집합을 원본으로 하는 데이터를 WINDOW FUNCTION과 함께 사용한다면 GROUP BY 절과 함께 WINDOW FUNCTION을 사용한다고 하더라도 오류가 발생하지 않는다.

- 유사 개수 칼럼은 상품분류코드로 GROUPING 된 집합을 원본집합으로 하여 상품분류코드별 평균상품가격을 서로 비교하여 현재 읽힌 상품분류코드의 평균가격 대비 -10000 ~ +10000사이에 존재하는 상품분류코드의 개수를 구한 것이다.