# 오답 노트

### 57번 문제

- GROUPING STES 는 지정한 그룹별 집계

- ROLLUP 은 단계별 소계

- CUBE 는 가능한 모든 조합별 소계

```
3,4번 보기의 grade 는

롤업이나 큐브에 영향을 받지 않습니다. 괄호 밖에 있는 것에 주목.

즉, grade 는 롤업, 큐브의 결과에 항상 기본으로 포함된다고 보시면 됩니다.
```
1) (grade), (job, grade) 

2) (grade, job), (grade), ()

3) 롤업의 결과가 (job), () 이므로. 여기에 grade 를 기본으로 포함시키면 (grade, job), (grade) 가 됩니다.

4) 큐브의 결과가 (job), () 이므로. 여기에 grade 를 기본으로 포함시키면 (grade, job), (grade) 가 됩니다.

### 66번 문제

1) 일자별매출액에 일자별 매출 테이블과 동일하게 출력된다.

2) 작은 날짜쪽에 제일 큰 누적금액이 출력된다.

4) 작은 날짜쪽에 제일 큰 누적금액이 출력된다.

3) 일자별매출 테이블을 SELF JOIN하여, A Alias 쪽에 먼저 읽혔다고 가정하면 다음처럼 데이터가 생성될 것이다.

    1. A가 2015.11.01 1000 일 때 B는 2015.11.01 1000

    2. A가 2015.11.02 1000 일 때 B는 2015.11.01 1000, 2015.11.02 1000

    3. A가 2015.11.03 1000 일 때 B는 2015.11.01 1000, 2015.11.02 1000, 2015.11.03 1000

- 위의 SELF JOIN은 EQUI JOIN이 아닌 RANGE JOIN이므로 A의 레코드는 B의 레코드 수만큼 증가한다. (A * B) 그러므로 위의 3번의 경우 A는 B의 레코드 개수와 동일하게 되므로 SUM(매출금액)을 하면 3000이 된다. 이런 식으로 A Alias의 모든 레코드 개수를 Scan하면 누적 값을 출력하게 된다.

- 이 쿼리는 누적매출액을 만들기 위해서, n일치의 데이터가 있을 때,

```
1일차 매출 * n+1-1
2일차 매출 * n+1-2
3일차 매출 * n+1-3
n일차 매출 * n+1-n
```

- 위와 같은 수의 많은 중복 행을 만들어서 일자별로(GROUP BY) 더하는(SUM) 방식입니다.

- A 기준으로 묶으면 각 일자별로 자기 일자보다 작거나 같은 일자의 매출이 그룹바이썸되고,

- B 기준으로 묶으면 각 일자별로 자기 일자보다 크거나 같은 일자 수 만큼, '자기 매출'이 멀티플라이됩니다.

### 68번 문제

- 다중 컬럼 서브쿼리는 SQL Server에서 사용 불가

### 72번 문제

1) 단일 행 서브쿼리의 비교 연산자로는 `=, <, <=, >, >=, <>`가 되어야 한다. IN, ALL 등의 비교 연산지는 다중 행 서브쿼리의 비교연산자이다.

2) 단일 행 서브쿼리의 비교연산자는 다중 행 서브쿼리의 비교 연산자로 사용할 수 없지만, 반대의 경우는 가능하다.

3) 비 연관 서브쿼리가 주로 메인쿼리에 값을 제공하기 위한 목적으로 사용된다.

4) 메인쿼리의 결과가 서브쿼리로 제공될 수도 있고, 서브쿼리의 결과가 메인쿼리로 제공될 수도 있으므로 실행 순서는 상황에 따라 달라진다.

### 73번 문제

- 2014년에 입사한 사원들의 사원, 부서 정보와 부양가족수를 추출하는 SQL이다.

- SELECT 절에 사용된 서브쿼리는 단일 행 연관 서브쿼리로 JOIN으로도 변경이 가능하며, FROM 절에 사용된 서브쿼리는 Inline View 또는 Dynamic View이고, WHERE 절에 사용된 서브쿼리는 다중행 연관 서브쿼리이다.

3) 번 보기의 경우 이미 FROM절에 Inline View로 사원 테이블의 입사년도 조건을 명시하였으므로 WHERE 절의 EXISTS 조건은 부서와 사원 테이블 간의 JOIN조건에 의해 결과에 어떠한 영향도 미치지 못하므로 삭제되어도 무방하다.

### 74번 문제

1) Inline View D에서 평가결과 엔터티의 틀정상품 및 평가항목에 대한 최종 평가회차가 아닌 전체 데이터 중 평가회차가 가장 큰 값을 가지고 JOIN을 수행하므로 원하는 결과가 아니다.

2) 연관 서브쿼리를 활용하여 특정 상품, 평가항목별로 최종 평가회차와 JOIN을 수행하여 원하는 결과를 출력한다.

3) 특정 평가회차에 대한 결과가 아닌, 평가결과 엔터티의 평가회차, 평가등급, 평가일자 속성에 대해서 개별 MAX 값을 구하므로 원하는 결과가 아니다.

4) 특정 평가회차에 대한 결과가 아닌 상품ID, 평가항목ID 별로 개별 MAX 값을 구하므로 원하는 결과가 아니다.

### 78번 문제

- ROLLUP 함수 활용

- ROLLUP 집계 그룹 함수는 나열된 칼럼에 대해 계층 구조로 집계를 출력하는 함수로 ROLLUP(A, B)를 수행하면 (A, B)별 집계, A별 집계와 전체 집계를 출력할 수 있다.

1) CASE절의 GROUPING 함수의 사용이 잘못(0이 아닌 1이 되어야 함)되었음

3) CUBE를 사용하면 결합 가능한 모든 값에 대하여 다차원 집계를 생성한다.

4) GROUPING SETS를 사용하면 계층 구조 없이 지역에 대한 합계와 원별 합계를 각각 생성한다

- 롤업이나 큐브, 그룹핑 셋을 사용한 집계쿼리의 경우, 이 집계된 결과가 일반 집계인지? 소계인지? 구분하는 함수가 grouping 함수입니다.

- GROUPING(그룹컬럼) 의 결과는 그룹컬럼이 그대로 출력되는 행은 0 이 나오고. 그룹컬럼이 NULL 로 출력되는 행은 1 이 나옵니다.

- 1번 선지는 GROUP BY 지역명 을 했으므로 Select 절에 지역명 그대로 사용 가능합니다.

- 2번 선지는 GROUP BY 지역ID 를 했으므로 Select 절에 지역명 그대로 사용 불가능합니다.

    - 다만, 지역명은 지역ID 에 종속되고 지역명 과 지역ID 는 1:1 관계일 것입니다.

    - 따라서, 하나의 지역ID 안에는 지역명은 한가지 뿐일 것이고 MIN(지역명) 을 하면 그 지역명이 나올 것입니다. MAX(지역명)을 사용해도 됩니다.

### 88번 문제

- GROUP BY 절의 집합을 원본으로 하는 데이터를 WINDOW FUNCTION과 함께 사용한다면 GROUP BY 절과 함께 WINDOW FUNCTION을 사용한다고 하더라도 오류가 발생하지 않는다.

- 유사 개수 칼럼은 상품분류코드로 GROUPING 된 집합을 원본집합으로 하여 상품분류코드별 평균상품가격을 서로 비교하여 현재 읽힌 상품분류코드의 평균가격 대비 -10000 ~ +10000사이에 존재하는 상품분류코드의 개수를 구한 것이다.

### 126번 문제

1. 연관 서브쿼리를 활용한 UPDATE에서 WHERE 절은 UPDATE 대상이 되는 데이터의 범위를 결정하는데, WHERE 절이 누락되어 부서의 모든 데이터가 UPDATE 대상이 되므로 부서코드 A007, A008을 제외한 모든 데이터가 NULL 값으로 변경된다.

2. WHERE 절 조건이 부서임시가 아닌 부서 테이블이므로 A007, A008을 제외한 모든 데이터가 NULL 값으로 변경된다.

4. 1번과 같은 사유로 부서코드 A007, A008을 제외한 모든 데이터가 NULL 값으로 변경된다. 또한 변경일자를 하드 코딩하는 것이 답이 될 수 없다.